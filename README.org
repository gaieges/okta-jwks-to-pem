# This is a file written in Emacs and authored using org-mode (http://orgmode.org/)
# The corresponding Markdown file is generated by running the
# "M-x org-md-export-to-markdown" command from inside of Emacs.
# 
# The rest of the files are generated from this file by running the
# "M-x org-babel-tangle" command from inside of Emacs.
# 
# The options below control the behavior of org-md-export-to-markdown:
#
# Don't render a Table of Contents 
#+OPTIONS: toc:nil
# Don't render section numbers
#+OPTIONS: num:nil
# Turn of subscript parsing: http://super-user.org/wordpress/2012/02/02/how-to-get-rid-of-subscript-annoyance-in-org-mode/comment-page-1/
#+OPTIONS: ^:{}
* Introduction
  This is a Python script that fetches JWKS results, and for
  each jwk, uses the *modulus* and *exponent* to generate a PEM encoded
  public key, suitable for use in tools like [[https://jwt.io][jwt.io]]

  Here is an example of using this tool to get the PEM encoded public
  keys for the "example.okta.com" Okta org:

  #+BEGIN_SRC sh :results code
    ./jwks_to_pem.py --url example.okta.com
  #+END_SRC

  #+BEGIN_SRC sh
  Fetching JWKS from example.okta.com
  PEM for KID 're7eOFV6SiygSbCyYHGGdERFCJ_EoNpi9Duv0FIxllo'
  -----BEGIN PUBLIC KEY-----
  MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAgVdVgO4RogxtWt4XN2vO
  9SG3Ekt6Qh+k6Io28dTNjEWuNxCYCtQI2dFtFs2y7OyLxQ2e3491XTDVRxtUx/Kl
  RhQCcGDtLM5vTRWtGo39heg9dLWv7mqlk+jVkJrK2vAO+0bfl0x2Ouov4VS4Ixwx
  lJfaec8v0cw+xjcJc29Y28WNFYhW/wpf1uEHYAf/pQ9q7S25rhK5yPv23101P7pA
  bCNDyFB6PYLuXxqkE7dq7rIZXfw5xgNQBRugBrSmUEjoCFs3XowAXCk2gWhM/1Lg
  mSqaaAh/Cu5vvzM0wYoaEi598LWYmtgurQ3C2Nenu8HVjI+zCSg8v7VrcTa1MHua
  owIDAQAB
  -----END PUBLIC KEY-----

  PEM for KID 'kTP2cLZY0qA2qfnedNEgx6rs6yqIEdf4DQYYV2m4KPQ'
  -----BEGIN PUBLIC KEY-----
  MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjKb91FLaoZe9/5NEMZrO
  1eDn4hdrhtjrvsy+qO1QIbbdhRXJIJoE+qpHmgmq1gK28OZCV51xUAwk8ugw5p7/
  m2wIarykHtXuBmhcFPkWez6N/yX30qvdOPPKUGqd05AoGcrzAW6fV07CRROU+5g1
  RnTdNasLEMYaq0xPlmCMDjb3usyiafGyyrwg4+tndOTry4uMtF7LeTVLZo9Tnn2x
  dJiytWWh+Rq5/KAn1mJ2GgwG8tp8o7SRf65c0LYQenN1d6vXX/Iimq/mg//B5CHP
  zIaUrZfoL+2sbRIyQ5AePlDyn8Neg6sIsV9nTkPAcYvvQsS+/8xnfNq6np0zKbua
  dQIDAQAB
  -----END PUBLIC KEY-----

  #+END_SRC

* Installing
  This Python script depends on the =cryptography= and =requests= Python
  2.7 packages

  The easiest way to install these dependencies is to use the [[https://nixos.org/nix/][Nix
  package manager]], which will automatically install these dependencies
  for you if you run the commands below.

  #+BEGIN_QUOTE
  Note: While Nix is the easiest way to install the dependencies for
  this script, Nix will download several hundred [[https://en.wikipedia.org/wiki/Mebibyte][MiB]] of packages these
  dependencies. If you don't want to use the Nix package manager, you
  can install the dependencies manually using your preferred package
  manager and then change the interpreter on the first line of
  included script from "=/usr/bin/env nix-shell=" to "=/usr/env/python="
  #+END_QUOTE

  Here is how to install this script on your system using the Nix
  package manager on GNU/Linux or Macintosh OS X systems:

  1. Install the Nix package manager:
     #+BEGIN_SRC sh
       curl https://nixos.org/nix/install | sh
     #+END_SRC
  2. Download the =get_id_token.sh= shell script to your system
     #+BEGIN_SRC sh
     git clone git@github.com:jpf/okta-jwks-to-pem.git
     #+END_SRC
  3. Change to the directory containing the =get_id_token.sh= shell
     script
     #+BEGIN_SRC sh
     cd okta-jwks-to-pem
     #+END_SRC
  4. Run the script:
     #+BEGIN_SRC sh
     ./jwks-to-pem.py --url example.okta.org
     #+END_SRC
* How it works
  The most important part of this code is the conversion of RSA public
  key modulus and exponent integers into a PEM encoded public key.

  Thanks to the excellent [[https://cryptography.io/en/latest/][Python cryptography]] library, the process of
  converting an RSA public key modulus and exponent is three step
  process:

  1. Convert the JWK modulus and exponent, which are Base64url
     encoded, into integers:
     #+NAME: convert-base64url-to-long
     #+BEGIN_SRC python
       exponent = base64_to_long(jwk['e'])
       modulus = base64_to_long(jwk['n'])
     #+END_SRC
     Note: This conversion is actually pretty frustrating, the
     =base64_to_long= function abstracts this all away.
  2. Use the [[https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa/#cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicNumbers][RSAPublicNumbers]] class to store the modulus and exponent
     #+NAME: create-rsapublicnumbers-object
     #+BEGIN_SRC python
       numbers = RSAPublicNumbers(exponent, modulus)
       public_key = numbers.public_key(backend=default_backend())
     #+END_SRC
  3. [[https://cryptography.io/en/latest/hazmat/primitives/asymmetric/serialization/][Serialize the RSAPublicNumbers object]] to PEM
     #+NAME: serialize-rsapublicnumbers-to-pem
     #+BEGIN_SRC python
       pem = public_key.public_bytes(
           encoding=serialization.Encoding.PEM,
           format=serialization.PublicFormat.SubjectPublicKeyInfo
       )
     #+END_SRC

  We cover the rest of the script below.

  First, we import the libraries that we'll need:
  - =argparse=: For handling the =--url== command line argument and giving
    help when it isn't present.
  - =base64=, =six=, =struct=: Used to properly decode the Base64url encoded modulus
    and exponent.
  - =cryptography=: For conversion of the modulus and exponent to PEM
  - =requests=: To fetch the JWKS URI

  Here is how we import the dependencies listed above:
  #+NAME: imports
  #+BEGIN_SRC python
    import argparse
    import base64
    import six
    import struct

    from cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicNumbers
    from cryptography.hazmat.backends import default_backend
    from cryptography.hazmat.primitives import serialization
    import requests
  #+END_SRC

  Next, we set up =ArgumentParser= to handle the =--url= command line
  argument. The =required=true= option will cause =ArgumentParser= to give
  help text if the =--url= argument isn't present.

  #+NAME: parse-arguments
  #+BEGIN_SRC python
    arg_parser = argparse.ArgumentParser(
        description='JWK to PEM conversion tool')
    arg_parser.add_argument('--url',
                            dest='org',
                            help='Domain for Okta org',
                            required=True)
    args = arg_parser.parse_args()
  #+END_SRC
  
  Next up is the the code that handles the ugly job of decoding and properly padding
  the base64url encoded strings that are used in a JWK. 

  This is easily the most frustrating part of dealing with a
  JWK. Particularly annoying is the fact that the keys are not Base64
  encoded, the are /Base64url/ encoded. Which means that we need to take
  special precautions for padding and decoding. Thankfully, I was able
  to find some code that already does this, written by the prolific
  and talented [[https://github.com/rohe][Roland Hedberg]]. The functions below come from:
  https://github.com/rohe/pyjwkest/blob/master/src/jwkest/__init__.py

  #+NAME: base64url-to-int
  #+BEGIN_SRC python
    def intarr2long(arr):
        return int(''.join(["%02x" % byte for byte in arr]), 16)


    def base64_to_long(data):
        if isinstance(data, six.text_type):
            data = data.encode("ascii")

        # urlsafe_b64decode will happily convert b64encoded data
        _d = base64.urlsafe_b64decode(bytes(data) + b'==')
        return intarr2long(struct.unpack('%sB' % len(_d), _d))

  #+END_SRC

  Here we fetch and decode the JSON from an Okta =jwks_uri= endpoint:

  #+NAME: fetch-jwks-uri
  #+BEGIN_SRC python
    print("Fetching JWKS from {}".format(args.org))
    r = requests.get("https://{}/oauth2/v1/keys".format(args.org))
    jwks = r.json()
  #+END_SRC

  Finally, we process each key, and print out the PEM encoded key for
  each JWK Key ID (=kid=) that we find:

  #+NAME: process-jwks
  #+BEGIN_SRC python :noweb yes
    for jwk in jwks['keys']:
        <<convert-base64url-to-long>>
        <<create-rsapublicnumbers-object>>
        <<serialize-rsapublicnumbers-to-pem>>

        print "PEM for KID '{}'".format(jwk['kid'])
        print pem
  #+END_SRC

  #+BEGIN_SRC python :tangle jwks_to_pem.py :noweb yes :exports none :padline no
    #! /usr/bin/env nix-shell
    #! nix-shell -i python -p python27Packages.requests2 -p python27Packages.cryptography

    <<imports>>

    <<parse-arguments>>

    <<base64url-to-int>>

    <<fetch-jwks-uri>>

    <<process-jwks>>
  #+END_SRC
* Requirements							   :noexport:
  #+TBLNAME: requirements-table
  |--------------+----------+---------+----------------------------------------------+--------------------------------------------+-------------------+--------------------------------------------------------------|
  | name         | equality | version | description                                  | url                                        | license           | license_url                                                  |
  |--------------+----------+---------+----------------------------------------------+--------------------------------------------+-------------------+--------------------------------------------------------------|
  | requests     | >=       |  2.11.1 | HTTP Requests for Humans                     | https://cryptography.io/                   | Apache 2.0 or BSD | https://github.com/pyca/cryptography/blob/master/LICENSE     |
  | cryptography | >=       |   1.5.2 | Exposes cryptographic recipes and primitives | http://docs.python-requests.org/en/latest/ | Apache 2.0        | https://github.com/kennethreitz/requests/blob/master/LICENSE |
  |--------------+----------+---------+----------------------------------------------+--------------------------------------------+-------------------+--------------------------------------------------------------|
** How to turn the table above into a requirements.txt file	   :noexport:
   To turn the table above into a =requirements.txt= file, we need to
   do the following:
   1. Convert the table into an array of dictionaries.
   2. Iterate through the array of dictionaries and construct output in
      the =requirements.txt= format, the output must be annotated so
      that it is written to =requirements.txt= when =M-x
      org-bable-tangle= is run on this file.
** Converting the table to an array of dictionaries		   :noexport:
  The code below is taken verbatim from [[http://stackoverflow.com/a/8414248/3191847][a StackOverflow answer]] by [[http://stackoverflow.com/users/174728/john-la-rooy][John
  La Rooy]]. This code takes the table above as an array of arrays and
  returns an array of dictionaries, where the key is the column name
  and the value is the column content. This array of dictionaries is
  used below to generate the =requirements.txt= file.
  #+NAME: table-to-dict
  #+BEGIN_SRC python :var table=requirements-table :results code :cache yes
    headers = table[0]
    values = table[1:]

    from functools import partial
    from itertools import izip, imap
    data = map(dict, imap(partial(izip, headers), values))

    return data
  #+END_SRC
  #+RESULTS[7f787f8512ce1f4160f632055852f2b43fb5dbed]: table-to-dict
  #+BEGIN_SRC python
  [{'equality': '>=', 'name': 'requests', 'license': 'Apache 2.0 or BSD', 'url': 'https://cryptography.io/', 'version': '2.11.1', 'license_url': 'https://github.com/pyca/cryptography/blob/master/LICENSE', 'description': 'HTTP Requests for Humans'}, {'equality': '>=', 'name': 'cryptography', 'license': 'Apache 2.0', 'url': 'http://docs.python-requests.org/en/latest/', 'version': '1.5.2', 'license_url': 'https://github.com/kennethreitz/requests/blob/master/LICENSE', 'description': 'Exposes cryptographic recipes and primitives'}]
  #+END_SRC

** Creating the =requirements.txt= file				   :noexport:
  This code takes the requirements table above and turns it into a
  =requirements.txt= file that will get exported when =M-x
  org-bable-tangle= is run.

  #+HEADER: :results_switches ":tangle requirements.txt :noweb yes :exports none :padline no"
  #+BEGIN_SRC python :var table=requirements-table :results code :noweb yes :cache yes
    data = <<table-to-dict(requirements-table)>>
    output = ''
    for package in data:
	if not package['name']:
	    continue
	output += "{name}{equality}{version}\n".format(**package)
    return output
  #+END_SRC

  #+RESULTS[c159eb05f7c3ed9feb34f214884ca276a9cc10aa]:
  #+BEGIN_SRC python :tangle requirements.txt :noweb yes :exports none :padline no
  requests>=2.11.1
  cryptography>=1.5.2
  #+END_SRC

* Dependencies
  This script depends on the command line tools listed below. These
  requirements should be automatically included via the =nix-shell=
  directives in the script, but are listed below for the sake of
  completeness.

  #+BEGIN_SRC python :var table=requirements-table :results html :noweb yes :cache yes :exports results
    data = <<table-to-dict(requirements-table)>>
    output = "| Name | Version | Description | License |\n"
    output += "| ---- | --- | --- | --- |\n"
    for package in data:
	if not package['name']:
	    continue
	output += "| [{name}]({url}) | {version} | {description} | [{license}]({license_url}) |\n".format(**package)
    return output
  #+END_SRC

  #+RESULTS[2f1bc451b8a6bfd5e67a98ad8965a7823fac6016]:
  #+BEGIN_HTML
  | Name | Version | Description | License |
  | ---- | --- | --- | --- |
  | [requests](https://cryptography.io/) | 2.11.1 | HTTP Requests for Humans | [Apache 2.0 or BSD](https://github.com/pyca/cryptography/blob/master/LICENSE) |
  | [cryptography](http://docs.python-requests.org/en/latest/) | 1.5.2 | Exposes cryptographic recipes and primitives | [Apache 2.0](https://github.com/kennethreitz/requests/blob/master/LICENSE) |
  #+END_HTML

* License information
  #+NAME: license
  #+BEGIN_SRC text :tangle LICENSE.txt :padline no
    Copyright © 2016, Okta, Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
  #+END_SRC
* To do								   :noexport:
** DONE Add "dependencies" list
** DONE Generate =requirements.txt= file from dependencies
** DONE Add license
